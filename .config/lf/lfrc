# Author: Rafael Cavalcanti <https://rafaelc.org/dev>

# Set internal field separator (IFS) to "\n" for shell commands.
set ifs "\n"

# Run commands on bash.
set shell bash

# Previewer.
set previewer ~/.config/lf/previewer.sh
# Needed for image preview with ueberzug.
set cleaner ~/.config/lf/previewer_img/clear_img.sh
# Make "i" use the previewer output.
map i $~/.config/lf/previewer.sh $f | less -R

# Multiple appearance options.
set icons
set number
set relativenumber

# Show file size and file count for directory.
set info size
set dircounts

# Leave some space at the top and the bottom of the screen.
set scrolloff 10

# Automatic refresh.
set period 1

# Enable mouse.
set mouse


#########################
#         TRASH         #
#########################

# Move bind so t is available.
map t
map tt tag-toggle

# Send to trash or confirm delete, depending on availability.
cmd trash &{{
    if command -v gio >/dev/null; then
        gio trash $fx &> /dev/null
    else
        lf -remote "send $id delete"
    fi
}}
map <delete> trash

cmd trash-restore %{{
  set -f
  trash_path="/home/rafael/.local/share/Trash/files/"

  if [[ $fx != $trash_path* ]]; then
      echo "Not in trash."
  else
      ft=$(basename -a $fx|sed -e 's/^/trash:\/\/\//')
      gio trash --restore $ft
      echo "Restored $(basename -a $fx)"
  fi
}}
map tr trash-restore

# Force reload, or trash directory counting is not updated.
map te %gio trash --empty && echo "Trash emptied." && lf -remote "send $id reload"

map tl cd ~/.local/share/Trash/files


#########################
#       RENAMING        #
#########################

# Copied from
# <https://github.com/gokcehan/lf/wiki/Tips#bulk-rename-multiple-files>.
cmd bulk-rename ${{
    old="$(mktemp)"
    new="$(mktemp)"
    if [ -n "$fs" ]; then
        fs="$(basename -a $fs)"
    else
        fs="$(ls)"
    fi
    printf '%s\n' "$fs" >"$old"
    printf '%s\n' "$fs" >"$new"
    $EDITOR "$new"
    [ "$(wc -l < "$new")" -ne "$(wc -l < "$old")" ] && exit
    paste "$old" "$new" | while IFS= read -r names; do
        src="$(printf '%s' "$names" | cut -f1)"
        dst="$(printf '%s' "$names" | cut -f2)"
        if [ "$src" = "$dst" ] || [ -e "$dst" ]; then
            continue
        fi
        mv -- "$src" "$dst"
    done
    rm -- "$old" "$new"
    lf -remote "send $id unselect"
}}

# Choose bulk or default rename commands automatically.
cmd smart-rename &{{
    cursor_cmd="$1"
    set -- $fx
    selected=$#
    if [ $selected -gt 1 ]; then
        lf -remote "send $id bulk-rename"
    else
        lf -remote "send $id :rename; $cursor_cmd"
    fi
}}

# Maps for renaming.
map <f-2> smart-rename
map A smart-rename
map C smart-rename "cmd-delete-home"
map I smart-rename "cmd-home"
map r #unmap


#########################
# COMMANDS AND MAPPINGS #
#########################

# Map ctrl+backspace.
cmap <backspace> cmd-delete-unix-word

# Edit and reload config.
cmd edit-config ${{
    $EDITOR ~/.config/lf/lfrc
    lf -remote "send $id source ~/.config/lf/lfrc"
}}
map E edit-config

# Also use enter to open.
map <enter> open

# File opener actions.
map L $mimeopen --ask $f

# Define a custom 'open' command.
# Uses an editor for text files and a file opener for the rest.
cmd open &{{
    case $(file --mime-type -Lb $f) in
        text/*) lf -remote "send $id \$$EDITOR \$fx";;

        # Useful to touch files and open with lf.vim.
        inode/x-empty) lf -remote "send $id \$$EDITOR \$fx";;

        *) for f in $fx; do $OPENER $f > /dev/null 2> /dev/null & done;;
    esac
}}

# Move copy mapping so we can set more mappings starting with "y".
map y
map yy copy

# Copy path to clipboard.
cmd yank-dirname $dirname -- "$f" | head -c-1 | xclip -i -selection clipboard
cmd yank-path $printf '%s' "$fx" | xclip -i -selection clipboard
cmd yank-name $basename -a -- $fx | head -c-1 | xclip -i -selection clipboard
map yd yank-dirname
map yp yank-path
map yn yank-name

# Run command on current file
map @ push !<space>$fx<home>

# Map for setting wallpaper.
map W &set-wallpaper $f

# Find file or dir with fzf.
# Args: extra arguments for fd.
cmd fzf_jump ${{
    res="$(fdfind . "$@" | fzf --header='Jump to...')"
    if [ -n "$res" ]; then
        if [ -d "$res" ]; then
            cmd="cd"
        else
            cmd="select"
        fi
        res="$(printf '%s' "$res" | sed 's/\\/\\\\/g;s/"/\\"/g')"
        lf -remote "send $id $cmd \"$res\""
    fi
}}
map f  # unmap
map ff :fzf_jump
map fd :fzf_jump --type d

# zsh-z integration to jump directories.
# lf doesn't seem to support completion, so we'll use fzf.
cmd z ${{
    options=$(zsh -c "source $ZSHZ_SRC && zshz -l")
    result="$(awk '{print $2}' <<< "$options" | fzf --header='z to directory...')"
    lf -remote "send $id cd \"$result\""
}}
map fz :z

cmd on-cd &{{
    # Hook for zsh-z on cd.
    zsh -c "source $ZSHZ_SRC && zshz --add \"$PWD\""
}}

# Create files and directories, similar to nvim-tree.
cmd create &{{
    IFS=' '
    path="$*"

    if [[ "${path:0-1}" == "/" ]]; then
        mkdir -p "$path"
    else
        touch "$path"
    fi

    lf -remote "send $id select \"$*\""
}}
map a push :create<space>

cmd extract $atool --extract --each -- $fx
map x :extract
